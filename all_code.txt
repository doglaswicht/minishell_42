===== File: ./src/env/env_init.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_init.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:31 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/05 16:53:32 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "env.h"

t_env	*init_env_from_environ(char **envp)
{
	t_env	*env;
	char	*sep;
	char	*key;
	char	*value;

	env = NULL;
	while (*envp)
	{
		sep = ft_strchr(*envp, '=');
		if (sep)
		{
			key = ft_substr(*envp, 0, sep - *envp);
			value = ft_strdup(sep + 1);
			add_env_node(key, value, &env);
			free(key);
			free(value);
		}
		envp++;
	}
	return (env);
}



===== File: ./src/env/env_helpers.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_helpers.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/06 14:45:00 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 14:05:54 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "env.h"

int	is_valid_env_key(const char *key)
{
	int	i;

	if (!key || !*key)
		return (0);
	if (!(ft_isalpha(key[0]) || key[0] == '_'))
		return (0);
	i = 1;
	while (key[i])
	{
		if (!(ft_isalnum(key[i]) || key[i] == '_'))
			return (0);
		i++;
	}
	return (1);
}

int	env_key_exists(t_env *env, const char *key)
{
	while (env)
	{
		if (ft_strncmp(env->key, key, ft_strlen(key)) == 0
			&& env->key[ft_strlen(key)] == '\0')
			return (1);
		env = env->next;
	}
	return (0);
}

static char	*create_env_string(t_env *tmp)
{
	char	*key_eq;
	char	*result;

	key_eq = ft_strjoin(tmp->key, "=");
	if (!key_eq)
		return (NULL);
	result = ft_strjoin(key_eq, tmp->value);
	free(key_eq);
	return (result);
}

char	**env_to_str_array(t_env *env)
{
	size_t	count;
	size_t	i;
	char	**arr;
	t_env	*tmp;

	count = 0;
	tmp = env;
	while (tmp && ++count)
		tmp = tmp->next;
	arr = malloc(sizeof(char *) * (count + 1));
	if (!arr)
		return (NULL);
	i = 0;
	tmp = env;
	while (tmp)
	{
		arr[i] = create_env_string(tmp);
		if (!arr[i])
		{
			while (i > 0)
				free(arr[--i]);
			free(arr);
			return (NULL);
		}
		i++;
		tmp = tmp->next;
	}
	arr[i] = NULL;
	return (arr);
}



===== File: ./src/env/env_unset.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_unset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:35 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 14:07:13 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "env.h"

int	unset_env_value(t_env **env, const char *key)
{
	t_env	*cur;
	t_env	*prev;
	size_t	klen;

	if (!env || !*env || !key)
		return (1);
	cur = *env;
	prev = NULL;
	klen = ft_strlen(key);
	while (cur)
	{
		if (ft_strncmp(cur->key, key, klen) == 0 && cur->key[klen] == '\0')
		{
			if (prev)
				prev->next = cur->next;
			else
				*env = cur->next;
			free(cur->key);
			free(cur->value);
			free(cur);
			return (0);
		}
		prev = cur;
		cur = cur->next;
	}
	return (0);
}



===== File: ./src/env/env_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:36 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/05 16:53:37 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "env.h"

void	add_env_node(char *key, char *value, t_env **env_list)
{
	t_env	*new;
	t_env	*last;

	new = malloc(sizeof(t_env));
	if (!new)
		return ;
	new->key = ft_strdup(key);
	new->value = ft_strdup(value);
	new->next = NULL;
	if (!*env_list)
		*env_list = new;
	else
	{
		last = *env_list;
		while (last->next)
			last = last->next;
		last->next = new;
	}
}



===== File: ./src/env/env_set.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_set.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:33 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 14:06:46 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "env.h"

static int	replace_value(t_env *node, const char *value)
{
	char	*new_value;

	new_value = ft_strdup(value);
	if (!new_value)
		return (1);
	free(node->value);
	node->value = new_value;
	return (0);
}

t_env	*new_env_node(char *key, char *value)
{
	t_env	*node;

	node = malloc(sizeof(t_env));
	if (!node)
		return (NULL);
	node->key = ft_strdup(key);
	node->value = ft_strdup(value);
	node->next = NULL;
	if (!node->key || !node->value)
	{
		free(node->key);
		free(node->value);
		free(node);
		return (NULL);
	}
	return (node);
}

int	set_env_value(t_env **env, const char *key, const char *value)
{
	t_env	*tmp;

	if (!env || !key || !value)
		return (1);
	if (!is_valid_env_key(key))
		return (1);
	tmp = *env;
	while (tmp)
	{
		if (ft_strncmp(tmp->key, key, ft_strlen(key)) == 0
			&& tmp->key[ft_strlen(key)] == '\0')
			return (replace_value(tmp, value));
		tmp = tmp->next;
	}
	add_env_node((char *)key, (char *)value, env);
	return (0);
}



===== File: ./src/env/env_get.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_get.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:30 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 13:19:57 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "env.h"
#include <stdio.h>

char	*get_env_value(t_env *env, const char *key)
{
	size_t	klen;

	if (!env || !key)
		return (NULL);
	klen = ft_strlen(key);
	while (env)
	{
		if (ft_strncmp(env->key, key, klen) == 0 && env->key[klen] == '\0')
			return (env->value);
		env = env->next;
	}
	return (NULL);
}

int	env_has_key(t_env *env, const char *key)
{
	size_t	klen;

	if (!env || !key)
		return (0);
	klen = ft_strlen(key);
	while (env)
	{
		if (ft_strncmp(env->key, key, klen) == 0 && env->key[klen] == '\0')
			return (1);
		env = env->next;
	}
	return (0);
}

void	print_env_list(t_env *env)
{
	while (env)
	{
		if (env->key && env->value)
			printf("%s=%s\n", env->key, env->value);
		env = env->next;
	}
}



===== File: ./src/env/env_free.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_free.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/04 15:23:45 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/08/05 16:53:28 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cleanup.h"

void	free_env_list(t_env *env)
{
	t_env	*tmp;

	while (env)
	{
		tmp = env->next;
		free(env->key);
		free(env->value);
		free(env);
		env = tmp;
	}
}



===== File: ./src/expansion/expand_env.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_env.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:59 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 09:21:40 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "expansion.h"
#include "libft.h"

/*
** expand_env_value
** ---------------------------------------------------------------------------
** Retrieves the value of the given environment variable key from the `env`
** list.  If the key does not exist an empty string is returned.  The returned
** string is dynamically allocated and must be freed by the caller.
*/
char	*expand_env_value(const char *key, t_env *env)
{
	char	*value;

	if (!key)
		return (safe_strdup(""));
	value = get_env_value(env, key);
	if (!value)
		return (safe_strdup(""));
	return (safe_strdup(value));
}

/*
** expand_var_token
** ---------------------------------------------------------------------------
** Expands a token that represents a variable (e.g. "$HOME").  If the token
** does not start with '$' it is duplicated as-is.  The returned string is
** dynamically allocated and must be freed by the caller.
*/
char	*expand_var_token(const char *token, t_env *env)
{
	char	*key;
	char	*value;
	int		len;

	if (!token)
		return (NULL);
	if (token[0] != '$')
		return (safe_strdup(token));
	key = extract_var_key(token + 1, &len);
	value = expand_env_value(key, env);
	free(key);
	return (value);
}



===== File: ./src/expansion/expand_exit.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_exit.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:54:02 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/05 16:54:03 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "expansion.h"
#include "libft.h"

/*
** expand_exit_status
** ---------------------------------------------------------------------------
** Converts the numeric exit status into a string so it can replace the special
** "$?" sequence in the input.  The returned string is dynamically allocated
** and must be freed by the caller.
*/
char	*expand_exit_status(const char *line, int status)
{
	(void)line;
	return (ft_itoa(status));
}



===== File: ./src/expansion/expand_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:54:07 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/05 16:54:08 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "expansion.h"
#include "libft.h"

/*
** is_expandable
** ---------------------------------------------------------------------------
** Checks if a character can start an environment variable name after the '$'
** sign.  Characters allowed are alphabetic letters, digits and the underscore
** character.  Returning 1 means the variable is expandable, 0 otherwise.
*/
int	is_expandable(char c)
{
	if (ft_isalnum((unsigned char)c) || c == '_')
		return (1);
	return (0);
}

/*
** extract_var_key
** ---------------------------------------------------------------------------
** Given a string starting at the first character after '$', extracts the
** variable key composed of alphanumeric characters and underscores.  The
** length of the key is stored in `len` when it is not NULL.  The returned
** string is heap-allocated and should be freed by the caller.
*/
char	*extract_var_key(const char *line, int *len)
{
	int	idx;

	if (!line)
		return (NULL);
	idx = 0;
	while (line[idx] && (ft_isalnum((unsigned char)line[idx])
			|| line[idx] == '_'))
		idx++;
	if (len)
		*len = idx;
	return (ft_strndup(line, idx));
}



===== File: ./src/expansion/expand_main.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_main.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:54:05 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/05 16:54:06 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "expansion.h"
#include "libft.h"

/*
** append_char
** ---------------------------------------------------------------------------
** Helper that appends a single character to a dynamically allocated string.
*/
static char	*append_char(char *str, char c)
{
	char	buf[2];
	char	*tmp;

	buf[0] = c;
	buf[1] = '\0';
	tmp = ft_strndup(buf, 1);
	str = ft_strjoin_free(str, tmp);
	free(tmp);
	return (str);
}

static char	*handle_exit_status(const char *line, int *i, int last_status)
{
	char	*status;

	status = expand_exit_status(&line[*i], last_status);
	*i += 2;
	return (status);
}

static char	*handle_variable_expansion(const char *line, int *i, t_env *env)
{
	int		len;
	char	*key;
	char	*value;

	key = extract_var_key(&line[*i + 1], &len);
	value = expand_env_value(key, env);
	free(key);
	*i += len + 1;
	return (value);
}

static char	*process_dollar_sign(const char *line, int *i, t_env *env,
		int last_status)
{
	if (line[*i + 1] == '?')
		return (handle_exit_status(line, i, last_status));
	else if (line[*i + 1] && is_expandable(line[*i + 1]))
		return (handle_variable_expansion(line, i, env));
	else
	{
		(*i)++;
		return (safe_strdup("$"));
	}
}

/*
** expand_variables
** ---------------------------------------------------------------------------
** Expands environment variables and the special `$?` sequence within the given
** line.  Expansion does not occur inside single quotes.  The returned string is
** dynamically allocated and must be freed by the caller.
*/
char	*expand_variables(const char *line, t_env *env, int last_status)
{
	char	*result;
	int		i;
	int		quote;

	if (!line)
		return (NULL);
	result = safe_strdup("");
	i = 0;
	quote = 0;
	while (line[i])
	{
		if (line[i] == '\'' || line[i] == '"')
		{
			if (!quote)
				quote = line[i];
			else if (quote == line[i])
				quote = 0;
			result = append_char(result, line[i++]);
		}
		else if (line[i] == '$' && quote != '\'')
		{
			char *expanded = process_dollar_sign(line, &i, env, last_status);
			result = ft_strjoin_free(result, expanded);
			free(expanded);
		}
		else
			result = append_char(result, line[i++]);
	}
	return (result);
}




===== File: ./src/utils/cd_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd_utils.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/26 22:54:50 by procha-r          #+#    #+#             */
/*   Updated: 2025/08/26 22:57:10 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtin.h"
#include "libft.h"
#include <unistd.h>
#include <stdio.h>

char	*get_target_path(t_cmd *cmd, t_shell *shell)
{
	if (cmd->argv[1])
		return (cmd->argv[1]);
	return (get_env_value(shell->env, "HOME"));
}

int	handle_cd_error(char *oldpwd)
{
	perror("cd");
	free(oldpwd);
	return (1);
}

void	update_env_dirs(t_shell *shell, char *oldpwd, char *cwd)
{
	if (oldpwd)
	{
		set_env_value(&shell->env, "OLDPWD", oldpwd);
		free(oldpwd);
	}
	if (cwd)
	{
		set_env_value(&shell->env, "PWD", cwd);
		free(cwd);
	}
}



===== File: ./src/utils/free_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:57:55 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 15:36:32 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cleanup.h"
#include "libft.h"

/*
** free_split
** ---------------------------------------------------------------------------
** Wrapper around libft's ft_free_split to centralise freeing logic.
*/
void	free_split(char **arr)
{
	ft_free_split(arr);
}



===== File: ./src/utils/str_join.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   str_join.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:57:59 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 15:41:03 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "utils.h"
#include "libft.h"
#include <stdlib.h>

/*
** ft_strjoin_free
** ---------------------------------------------------------------------------
** Joins two strings returning a newly allocated string containing the
** concatenation of s1 and s2.  The first string (s1) is freed.  If either
** parameter is NULL the function behaves accordingly:
**   - if s1 is NULL, a duplicate of s2 is returned;
**   - if s2 is NULL, s1 is returned (already allocated) without modification.
*/
char	*ft_strjoin_free(char *s1, char *s2)
{
	char	*joined;

	if (!s1 && !s2)
		return (NULL);
	if (!s1)
		return (safe_strdup(s2));
	if (!s2)
		return (s1);
	joined = ft_strjoin(s1, s2);
	if (!joined)
	{
		free(s1);
		print_error("strjoin failed");
		return (NULL);
	}
	free(s1);
	return (joined);
}



===== File: ./src/utils/str_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   str_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:58:00 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/26 23:06:04 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "utils.h"
#include "libft.h"
#include <limits.h>

/*
** ft_strdup_range
** ---------------------------------------------------------------------------
** Duplicates a substring from `src` starting at index `start` (inclusive) and
** ending at index `end` (exclusive). Returns a newly allocated string or NULL
** on error or if `start` is greater than `end`.
*/
char	*ft_strdup_range(const char *src, int start, int end)
{
	char	*dup;
	int		i;
	int		len;

	if (!src || start < 0 || end < start)
		return (NULL);
	len = end - start;
	dup = safe_malloc(len + 1);
	i = 0;
	while (i < len && src[start + i])
	{
		dup[i] = src[start + i];
		i++;
	}
	dup[i] = '\0';
	return (dup);
}

/*
** count_char
** ---------------------------------------------------------------------------
** Counts the occurrences of character `c` in the given string `str`.
*/
int	count_char(const char *str, char c)
{
	int	count;

	if (!str)
		return (0);
	count = 0;
	while (*str)
	{
		if (*str == c)
			count++;
		str++;
	}
	return (count);
}

/*
** split_len
** ---------------------------------------------------------------------------
** Returns the number of elements in a NULL-terminated array of strings.
*/
int	split_len(char **arr)
{
	int	i;

	if (!arr)
		return (0);
	i = 0;
	while (arr[i])
		i++;
	return (i);
}

/*
** ft_atoi_strict
** ---------------------------------------------------------------------------
** Converts the string `str` to an integer storing the result in `out`. The
** conversion is strict: returns 0 if string contains invalid chars or overflows.
*/
int	ft_atoi_strict(const char *str, int *out)
{
	long	result;
	int		sign;
	int		i;

	if (!str || !out)
		return (0);
	i = 0;
	sign = 1;
	if (str[i] == '+' || str[i] == '-')
	{
		if (str[i] == '-')
			sign = -1;
		i++;
	}
	if (!ft_isdigit((unsigned char)str[i]))
		return (0);
	result = 0;
	while (str[i])
	{
		if (!ft_isdigit((unsigned char)str[i]))
			return (0);
		result = result * 10 + (str[i] - '0');
		if (sign == 1 && result > INT_MAX)
			return (0);
		if (sign == -1 && -result < INT_MIN)
			return (0);
		i++;
	}
	*out = (int)(result * sign);
	return (1);
}



===== File: ./src/utils/malloc_helpers.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   malloc_helpers.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:57:57 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 15:40:03 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "utils.h"
#include "libft.h"
#include <stdlib.h>

/*
** safe_malloc
** ---------------------------------------------------------------------------
** Allocates memory of the requested size.  If the allocation fails the
** function prints an error message and terminates the program with EXIT_FAILURE.
*/
void	*safe_malloc(size_t size)
{
	void	*ptr;

	ptr = malloc(size);
	if (!ptr)
	{
		print_error("malloc failed");
		exit(EXIT_FAILURE);
	}
	return (ptr);
}

/*
** safe_calloc
** ---------------------------------------------------------------------------
** Allocates zero-initialised memory for an array.  Behaves like safe_malloc
** regarding error handling.
*/
void	*safe_calloc(size_t count, size_t size)
{
	void	*ptr;

	ptr = ft_calloc(count, size);
	if (!ptr)
	{
		print_error("calloc failed");
		exit(EXIT_FAILURE);
	}
	return (ptr);
}

/*
** safe_strdup
** ---------------------------------------------------------------------------
** Duplicates a string using ft_strdup and exits on allocation failure.
*/
char	*safe_strdup(const char *s)
{
	char	*dup;

	if (!s)
		return (NULL);
	dup = ft_strdup(s);
	if (!dup)
	{
		print_error("strdup failed");
		exit(EXIT_FAILURE);
	}
	return (dup);
}



===== File: ./src/utils/error.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:57:52 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 15:35:40 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "utils.h"
#include "libft.h"

/*
** print_error
** ---------------------------------------------------------------------------
** Writes the given error message to STDERR followed by a newline.  If the
** message pointer is NULL nothing is printed.  This function does not append
** any prefix to the message, leaving formatting to the caller.
*/
void	print_error(const char *msg)
{
	if (msg)
		ft_putendl_fd((char *)msg, 2);
}

/*
** print_strs
** ---------------------------------------------------------------------------
** Utility function used for debugging purposes.  Receives a NULL-terminated
** array of strings and prints each element in its own line to STDOUT.  If the
** array itself is NULL, the function simply returns without producing any
** output.
*/
void	print_strs(char **arr)
{
	int	index;

	if (!arr)
		return ;
	index = 0;
	while (arr[index])
	{
		ft_putendl_fd(arr[index], 1);
		index++;
	}
}



===== File: ./src/quotes/quote_check.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   quote_check.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:56:23 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 15:15:11 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "quotes.h"

int	quotes_balanced(const char *line)
{
	int	i;
	int	quote;

	if (!line)
		return (1);
	i = 0;
	quote = 0;
	while (line[i])
	{
		if (!quote && is_quote(line[i]))
			quote = line[i];
		else if (quote && line[i] == quote)
			quote = 0;
		i++;
	}
	return (quote == 0);
}

int	contains_unclosed_quotes(const char *s)
{
	if (!s)
		return (0);
	return (!quotes_balanced(s));
}

int	is_quoted_segment(const char *s, int i)
{
	int	idx;
	int	quote;

	if (!s || i < 0)
		return (0);
	idx = 0;
	quote = 0;
	while (s[idx] && idx < i)
	{
		if (!quote && is_quote(s[idx]))
			quote = s[idx];
		else if (quote && s[idx] == quote)
			quote = 0;
		idx++;
	}
	return (quote != 0);
}



===== File: ./src/quotes/quote_type.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   quote_type.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:56:28 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 15:14:04 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "quotes.h"

int	is_quote(char c)
{
	return (c == '\'' || c == '"');
}

int	quote_type(char c)
{
	if (c == '\'')
		return ('\'');
	if (c == '"')
		return ('"');
	return (0);
}



===== File: ./src/quotes/quote_strip.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   quote_strip.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:56:26 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 15:12:55 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "quotes.h"
#include "libft.h"
#include "utils.h"

char	*remove_quotes(const char *str)
{
	char	*out;
	size_t	i;
	size_t	j;
	int		quote;

	if (!str)
		return (NULL);
	out = safe_malloc(ft_strlen(str) + 1);
	i = 0;
	j = 0;
	quote = 0;
	while (str[i])
	{
		if (!quote && is_quote(str[i]))
			quote = str[i];
		else if (quote && str[i] == quote)
			quote = 0;
		else
			out[j++] = str[i];
		i++;
	}
	out[j] = '\0';
	return (out);
}



===== File: ./src/exec/wait_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   wait_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/27 14:33:21 by procha-r          #+#    #+#             */
/*   Updated: 2025/08/27 14:49:38 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <sys/wait.h>

int	update_exit_code_from_status(int status)
{
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	if (WIFSIGNALED(status))
		return (128 + WTERMSIG(status));
	return (1);
}


===== File: ./src/exec/exec_single.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_single.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/06 14:30:00 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 14:32:39 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "exec.h"
#include "builtin.h"
#include "redir.h"
#include <unistd.h>

static void	restore_stdio(int saved[2])
{
	if (saved[0] >= 0)
	{
		dup2(saved[0], STDIN_FILENO);
		close(saved[0]);
	}
	if (saved[1] >= 0)
	{
		dup2(saved[1], STDOUT_FILENO);
		close(saved[1]);
	}
}

static int	handle_builtin_execution(t_cmd *cmd, t_shell *shell)
{
	int		saved[2];

	saved[0] = dup(STDIN_FILENO);
	saved[1] = dup(STDOUT_FILENO);
	if (saved[0] < 0 || saved[1] < 0 || handle_redirections(cmd, shell) < 0)
	{
		restore_stdio(saved);
		return (shell->last_exit_code = 1);
	}
	shell->last_exit_code = execute_builtin(cmd, shell);
	restore_stdio(saved);
	return (shell->last_exit_code);
}

int	execute_single_command(t_cmd *cmd, t_shell *shell)
{
	pid_t	pid;
	int		status;
	int		fds[2];

	if (!cmd)
		return (0);
	if (is_builtin(cmd))
		return (handle_builtin_execution(cmd, shell));
	fds[0] = STDIN_FILENO;
	fds[1] = STDOUT_FILENO;
	pid = spawn_child_process(cmd, shell, fds, 1);
	if (pid < 0)
		return (shell->last_exit_code = 1);
	waitpid(pid, &status, 0);
	if (WIFEXITED(status))
		shell->last_exit_code = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
		shell->last_exit_code = 128 + WTERMSIG(status);
else
		shell->last_exit_code = 1;
	shell->last_exit_code = shell->last_exit_code;
	return (shell->last_exit_code);
}



===== File: ./src/exec/exec_pipeline.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_pipeline.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:47 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 13:05:14 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "exec.h"
#include "builtin.h"
#include <unistd.h>
#include <stdlib.h>

static int	count_cmds(t_cmd *cmds)
{
	int	count;

	count = 0;
	while (cmds)
	{
		count++;
		cmds = cmds->next;
	}
	return (count);
}

static int	setup_pipeline_execution(t_cmd *cmds, t_shell *shell)
{
	shell->pipe_count = setup_pipes(cmds, &shell->pipes);
	if (shell->pipe_count < 0)
		return (-1);
	return (0);
}

static int	execute_pipeline_commands(t_cmd *cmds, t_shell *shell)
{
	int		i;
	int		fds[2];
	t_cmd	*tmp;

	tmp = cmds;
	i = 0;
	while (tmp)
	{
		fds[0] = (i == 0) ? STDIN_FILENO : shell->pipes[i - 1][0];
		fds[1] = (i == shell->pipe_count) ? STDOUT_FILENO : shell->pipes[i][1];
		if (spawn_child_process(tmp, shell, fds, i == shell->pipe_count) < 0)
		{
			close_all_pipes(shell->pipes, shell->pipe_count);
			free_pipe_fds(shell->pipes, shell->pipe_count);
			return (-1);
		}
		tmp = tmp->next;
		i++;
	}
	return (0);
}

int	execute_pipeline(t_cmd *cmds, t_shell *shell)
{
	int	cmd_count;

	if (!cmds)
		return (0);
	cmd_count = count_cmds(cmds);
	if (cmd_count == 1)
		return (execute_single_command(cmds, shell));
	if (setup_pipeline_execution(cmds, shell) < 0)
		return (1);
	if (execute_pipeline_commands(cmds, shell) < 0)
		return (1);
	close_all_pipes(shell->pipes, shell->pipe_count);
	shell->last_exit_code = wait_for_all(cmds, shell);
	free_pipe_fds(shell->pipes, shell->pipe_count);
	shell->pipes = NULL;
	shell->pipe_count = 0;
	return (shell->last_exit_code);
}



===== File: ./src/exec/exec_path.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_path.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:45 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/05 16:53:46 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "exec.h"
#include <sys/stat.h>

int	is_path_absolute_or_relative(const char *cmd)
{
	return (cmd && (cmd[0] == '/' || cmd[0] == '.'));
}

int	is_valid_executable(const char *path)
{
	struct stat	sb;

	if (!path)
		return (0);
	if (access(path, X_OK) != 0)
		return (0);
	if (stat(path, &sb) != 0)
		return (0);
	if (S_ISDIR(sb.st_mode))
		return (0);
	return (1);
}

static char	*search_in_paths(char **paths, char *cmd)
{
	char	*tmp;
	char	*candidate;
	int		i;

	i = 0;
	while (paths[i])
	{
		tmp = ft_strjoin(paths[i], "/");
		candidate = ft_strjoin(tmp, cmd);
		free(tmp);
		if (is_valid_executable(candidate))
		{
			ft_free_split(paths);
			return (candidate);
		}
		free(candidate);
		i++;
	}
	return (NULL);
}

char	*resolve_command_path(char *cmd, t_env *env)
{
	char	*path_env;
	char	**paths;
	char	*result;

	if (is_path_absolute_or_relative(cmd))
	{
		if (is_valid_executable(cmd))
			return (ft_strdup(cmd));
		return (NULL);
	}
	path_env = get_env_value(env, "PATH");
	if (!path_env)
		return (NULL);
	paths = ft_split(path_env, ':');
	if (!paths)
		return (NULL);
	result = search_in_paths(paths, cmd);
	if (!result)
		ft_free_split(paths);
	return (result);
}



===== File: ./src/exec/wait.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   wait.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:52 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 14:50:52 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "exec.h"
#include <sys/wait.h>
#include "minishell.h"
/*
static void	update_exit_code_from_status(t_shell *shell, int status)
{
	if (WIFEXITED(status))
		shell->last_exit_code = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
		shell->last_exit_code = 128 + WTERMSIG(status);
	else
		shell->last_exit_code = 1;
}
*/
int	wait_for_all(t_cmd *cmds, t_shell *shell)
{
	int		count;
	int		status;
	t_cmd	*tmp;

	count = 0;
	tmp = cmds;
	while (tmp)
	{
		count++;
		tmp = tmp->next;
	}
	status = 0;
	if (shell->last_pid > 0)
		waitpid(shell->last_pid, &status, 0);
	count--;
	while (count-- > 0)
		wait(NULL);
	update_exit_code_from_status(status);
	return (shell->last_exit_code);
}



===== File: ./src/exec/exec_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:49 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/05 16:53:50 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "exec.h"
#include <stdio.h>

void	handle_exec_error(const char *msg)
{
	if (msg)
		perror(msg);
}



===== File: ./src/exec/exec_fork.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_fork.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:43 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 14:31:12 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "exec.h"
#include "builtin.h"
#include "redir.h"
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>

static void	free_envp(char **envp)
{
	int	i;

	if (!envp)
		return ;
	i = 0;
	while (envp[i])
		free(envp[i++]);
	free(envp);
}

void	child_process_exec(t_cmd *cmd, t_shell *shell, int is_last)
{
	int	status;

	(void)is_last;
	if (handle_redirections(cmd, shell) < 0)
		exit(1);
	if (is_builtin(cmd))
	{
		status = execute_builtin(cmd, shell);
		exit(status);
	}
	exit(launch_execve(cmd, shell));
}

int	spawn_child_process(t_cmd *cmd, t_shell *shell, int *fds, int is_last)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		handle_exec_error("fork");
		return (-1);
	}
	if (pid == 0)
	{
		if (fds[0] != STDIN_FILENO)
			dup2(fds[0], STDIN_FILENO);
		if (fds[1] != STDOUT_FILENO)
			dup2(fds[1], STDOUT_FILENO);
		close_all_pipes(shell->pipes, shell->pipe_count);
		child_process_exec(cmd, shell, is_last);
	}
	if (is_last)
		shell->last_pid = pid;
	return (pid);
}

int	launch_execve(t_cmd *cmd, t_shell *shell)
{
	char	*path;
	char	**envp;
	int		ret;

	path = resolve_command_path(cmd->argv[0], shell->env);
	envp = env_to_str_array(shell->env);
	if (!path)
	{
		fprintf(stderr, "%s: command not found\n", cmd->argv[0]);
		free_envp(envp);
		return (127);
	}
	execve(path, cmd->argv, envp);
	ret = errno;
	handle_exec_error(cmd->argv[0]);
	free(path);
	free_envp(envp);
	if (ret == EACCES)
		return (126);
	return (127);
}



===== File: ./src/exec/pipes.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipes.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:51 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/05 16:53:52 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "exec.h"
#include <stdlib.h>
#include <unistd.h>

static int	count_commands(t_cmd *cmds)
{
	int	count;

	count = 0;
	while (cmds)
	{
		count++;
		cmds = cmds->next;
	}
	return (count - 1);
}

static int	allocate_pipes(int ***pipes, int count)
{
	int	i;

	*pipes = malloc(sizeof(int *) * count);
	if (!*pipes)
		return (-1);
	i = 0;
	while (i < count)
	{
		(*pipes)[i] = malloc(sizeof(int) * 2);
		if (!(*pipes)[i])
		{
			free_pipe_fds(*pipes, i);
			return (-1);
		}
		if (pipe((*pipes)[i]) == -1)
		{
			free_pipe_fds(*pipes, i + 1);
			return (-1);
		}
		i++;
	}
	return (0);
}

int	setup_pipes(t_cmd *cmds, int ***pipes)
{
	int	count;

	*pipes = NULL;
	count = count_commands(cmds);
	if (count <= 0)
		return (0);
	if (allocate_pipes(pipes, count) == -1)
		return (-1);
	return (count);
}

void	close_all_pipes(int **pipes, int count)
{
	int	i;

	if (!pipes)
		return ;
	i = 0;
	while (i < count)
	{
		close(pipes[i][0]);
		close(pipes[i][1]);
		i++;
	}
}

void	free_pipe_fds(int **pipes, int count)
{
	int	i;

	if (!pipes)
		return ;
	i = 0;
	while (i < count)
	{
		free(pipes[i]);
		i++;
	}
	free(pipes);
}



===== File: ./src/tokenizer/tokenizer.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenizer.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/06 12:25:12 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/08/26 23:11:48 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "tokenizer.h"
#include "libft.h"
#include <stdlib.h>

static void	skip_whitespace(const char *line, int *i)
{
	while (line[*i] && is_space(line[*i]))
		(*i)++;
}

static void	handle_word_token(const char *line, int *i, t_token **head)
{
	const char	*start;
	char		*value;
	char		quote;

	start = &line[*i];
	quote = 0;
	while (line[*i] && (quote || (!is_space(line[*i]) \
&& !is_metachar(line[*i]))))
	{
		if (is_quote(line[*i]))
		{
			if (!quote)
				quote = line[*i];
			else if (quote == line[*i])
				quote = 0;
		}
		(*i)++;
	}
	value = ft_strndup(start, *i - (start - line));
	add_token(head, new_token(value, TOKEN_WORD));
}

static void	handle_metachar_token(const char *line, int *i, t_token **head)
{
	char		*value;
	int			type;

	type = token_type(&line[*i]);
	if (type == TOKEN_HEREDOC || type == TOKEN_REDIR_APPEND
		|| type == TOKEN_AND_IF || type == TOKEN_OR_IF)
	{
		value = ft_strndup(&line[*i], 2);
		*i += 2;
	}
	else
	{
		value = ft_strndup(&line[*i], 1);
		(*i)++;
	}
	add_token(head, new_token(value, type));
}

t_token	*tokenize_input(const char *line)
{
	t_token	*head;
	int		i;

	if (!line)
		return (NULL);
	head = NULL;
	i = 0;
	while (line[i])
	{
		skip_whitespace(line, &i);
		if (line[i] && !is_metachar(line[i]))
			handle_word_token(line, &i, &head);
		else if (line[i] && is_metachar(line[i]))
			handle_metachar_token(line, &i, &head);
	}
	return (head);
}



===== File: ./src/tokenizer/token_free.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_free.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/06 12:15:18 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/08/06 15:27:17 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "tokenizer.h"
#include <stdlib.h>

void	free_token_list(t_token *head)
{
	t_token	*tmp;

	while (head)
	{
		tmp = head->next;
		free(head->value);
		free(head);
		head = tmp;
	}
}



===== File: ./src/tokenizer/token_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:57:36 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 15:33:38 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "tokenizer.h"
#include <stdlib.h>

int	is_space(char c)
{
	return (c == ' ' || c == '\t' || c == '\n'
		|| c == '\v' || c == '\f' || c == '\r');
}

int	is_metachar(char c)
{
	return (c == '|' || c == '<' || c == '>');
}

t_token	*new_token(const char *value, t_token_type type)
{
	t_token	*token;

	token = malloc(sizeof(t_token));
	if (!token)
		return (NULL);
	token->value = (char *)value;
	token->type = type;
	token->next = NULL;
	return (token);
}

void	add_token(t_token **list, t_token *new)
{
	t_token	*temp;

	if (!list || !new)
		return ;
	if (!*list)
	{
		*list = new;
		return ;
	}
	temp = *list;
	while (temp->next)
		temp = temp->next;
	temp->next = new;
}



===== File: ./src/tokenizer/token_type.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_type.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/06 12:16:07 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/08/06 15:30:12 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "tokenizer.h"

int	token_type(const char *str)
{
	if (str == NULL)
		return (TOKEN_UNKNOWN);
	if (str[0] == '|' && str[1] == '|')
		return (TOKEN_OR_IF);
	if (str[0] == '&' && str[1] == '&')
		return (TOKEN_AND_IF);
	if (str[0] == '<' && str[1] == '<')
		return (TOKEN_HEREDOC);
	if (str[0] == '>' && str[1] == '>')
		return (TOKEN_REDIR_APPEND);
	if (str[0] == '<')
		return (TOKEN_REDIR_IN);
	if (str[0] == '>')
		return (TOKEN_REDIR_OUT);
	if (str[0] == '|')
		return (TOKEN_PIPE);
	return (TOKEN_WORD);
}



===== File: ./src/parser/parser_main_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_main_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/26 23:17:51 by procha-r          #+#    #+#             */
/*   Updated: 2025/08/26 23:23:34 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"
#include "redir.h"
#include "quotes.h"
#include "libft.h"
#include <stdlib.h>

t_redir	*new_redirection(t_token_type type, const char *target)
{
	t_redir	*redir;

	redir = (t_redir *)malloc(sizeof(t_redir));
	if (!redir)
		return (NULL);
	redir->type = type;
	redir->target = ft_strdup(target);
	if (!redir->target)
	{
		free(redir);
		return (NULL);
	}
	redir->next = NULL;
	return (redir);
}

void	add_redirection(t_redir **list, t_redir *new_redir)
{
	t_redir	*tmp;

	if (!list || !new_redir)
		return ;
	if (!*list)
	{
		*list = new_redir;
		return ;
	}
	tmp = *list;
	while (tmp->next)
		tmp = tmp->next;
	tmp->next = new_redir;
}

int	process_word_token(t_cmd *current, t_token *token)
{
	char	*clean;

	if (current)
	{
		clean = remove_quotes(token->value);
		ft_add_arg(&current->argv, clean);
		free(clean);
	}
	return (0);
}

int	process_redirection_token(t_cmd *current, t_token **tokens)
{
	t_redir	*redir;

	if (!current || !(*tokens)->next || (*tokens)->next->type != TOKEN_WORD)
		return (-1);
	redir = new_redirection((*tokens)->type, (*tokens)->next->value);
	if (!redir)
		return (-1);
	add_redirection(&current->redir, redir);
	*tokens = (*tokens)->next;
	return (0);
}

t_cmd	*create_new_command(t_cmd **cmds, int needs_pipe, int segment_index)
{
	t_cmd	*current;

	current = new_command();
	if (!current)
	{
		free_command_list(*cmds);
		return (NULL);
	}
	if (needs_pipe && segment_index > 0)
		current->pipe_in = 1;
	add_command(cmds, current);
	return (current);
}



===== File: ./src/parser/ft_add_arg.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_add_arg.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/26 23:13:21 by procha-r          #+#    #+#             */
/*   Updated: 2025/08/26 23:15:48 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"
#include "cleanup.h"
#include "libft.h"
#include <stdlib.h>

void	ft_add_arg(char ***argv, const char *value)
{
	size_t	len;
	char	**new_argv;

	if (!value)
		return ;
	len = count_argv_len(*argv);
	new_argv = allocate_new_argv(len);
	if (!new_argv)
		return ;
	copy_argv(new_argv, *argv);
	new_argv[len] = ft_strdup(value);
	new_argv[len + 1] = NULL;
	free_old_argv(*argv);
	*argv = new_argv;
}



===== File: ./src/parser/parser_cmd.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_cmd.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:55:04 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/05 16:55:05 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"
#include <stdlib.h>

/*
** Allocate and initialize a new command structure
** Returns NULL on allocation failure
** The command is initialized with empty argv and redirection list
** pipe flags and builtin flag are set to 0
*/

t_cmd	*new_command(void)
{
	t_cmd	*cmd;

	cmd = (t_cmd *)malloc(sizeof(t_cmd));
	if (!cmd)
		return (NULL);
	cmd->argv = NULL;
	cmd->redir = NULL;
	cmd->pipe_in = 0;
	cmd->pipe_out = 0;
	cmd->is_builtin = 0;
	cmd->next = NULL;
	return (cmd);
}

/*
** Append a command to the end of the command list
** If the list pointer is NULL, the new command becomes the head
*/

void	add_command(t_cmd **cmds, t_cmd *new_cmd)
{
	t_cmd	*tmp;

	if (!cmds || !new_cmd)
		return ;
	if (!*cmds)
	{
		*cmds = new_cmd;
		return ;
	}
	tmp = *cmds;
	while (tmp->next)
		tmp = tmp->next;
	tmp->next = new_cmd;
}



===== File: ./src/parser/parser_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/06 12:27:50 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/08/26 23:14:28 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"
#include "cleanup.h"
#include "libft.h"
#include <stdlib.h>

void	free_command_list(t_cmd *cmds)
{
	t_cmd	*tmp;

	while (cmds)
	{
		tmp = cmds->next;
		free_command(cmds);
		cmds = tmp;
	}
}

size_t	count_argv_len(char **argv)
{
	size_t	len;

	len = 0;
	while (argv && argv[len])
		len++;
	return (len);
}

char	**allocate_new_argv(size_t len)
{
	char	**new_argv;

	new_argv = malloc(sizeof(char *) * (len + 2));
	return (new_argv);
}

void	copy_argv(char **new_argv, char **argv)
{
	size_t	i;

	i = 0;
	while (argv && argv[i])
	{
		new_argv[i] = ft_strdup(argv[i]);
		i++;
	}
}

void	free_old_argv(char **argv)
{
	size_t	i;

	if (argv)
	{
		i = 0;
		while (argv[i])
			free(argv[i++]);
		free(argv);
	}
}



===== File: ./src/parser/parser_split.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_split.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:55:13 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/26 23:09:54 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"

/*
** Count how many command segments exist in the list of tokens
** Segments are separated by PIPE tokens. Returns 0 for empty list
*/

int	count_command_segments(t_token *tokens)
{
	int	count;

	if (!tokens)
		return (0);
	count = 1;
	while (tokens)
	{
		if (tokens->type == TOKEN_PIPE)
			count++;
		tokens = tokens->next;
	}
	return (count);
}

/*
** Check if tokens contain at least one pipe
*/

int	command_needs_pipe(t_token *tokens)
{
	while (tokens)
	{
		if (tokens->type == TOKEN_PIPE)
			return (1);
		tokens = tokens->next;
	}
	return (0);
}

/*
** Determine if a command structure has no arguments and no redirections
*/

int	command_is_empty(t_cmd *cmd)
{
	if (!cmd)
		return (1);
	if ((!cmd->argv || !cmd->argv[0]) && cmd->redir == NULL)
		return (1);
	return (0);
}

/*
** Verify whether a token represents a redirection operator
*/

int	is_redirection_token(t_token *token)
{
	if (!token)
		return (0);
	if (token->type == TOKEN_REDIR_IN || token->type == TOKEN_REDIR_OUT
		|| token->type == TOKEN_REDIR_APPEND || token->type == TOKEN_HEREDOC)
		return (1);
	return (0);
}



===== File: ./src/parser/parser_main.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_main.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:55:10 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/26 23:27:57 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"
#include "redir.h"
#include "quotes.h"
#include "libft.h"
#include <stdlib.h>

static void	handle_pipe_token(t_cmd **current, int *segment_index,
		int needs_pipe, int total_segments)
{
	if (*current && !command_is_empty(*current)
		&& needs_pipe && *segment_index < total_segments - 1)
		(*current)->pipe_out = 1;
	*current = NULL;
	(*segment_index)++;
}

static t_cmd	*parse_token_loop(t_token *tokens, t_cmd **cmds,
		t_cmd **current, int needs_pipe)
{
	int	segment_index;
	int	total_segments;

	segment_index = 0;
	total_segments = count_command_segments(tokens);
	while (tokens)
	{
		if (!*current && tokens->type != TOKEN_PIPE)
		{
			*current = create_new_command(cmds, needs_pipe, segment_index);
			if (!*current)
				return (NULL);
		}
		if (tokens->type == TOKEN_WORD)
			process_word_token(*current, tokens);
		else if (is_redirection_token(tokens) && *current)
		{
			if (process_redirection_token(*current, &tokens) == -1)
				return (free_command_list(*cmds), NULL);
		}
		else if (tokens->type == TOKEN_PIPE)
			handle_pipe_token(current, &segment_index, \
needs_pipe, total_segments);
		tokens = tokens->next;
	}
	return (*cmds);
}

t_cmd	*parse_tokens_to_cmds(t_token *tokens)
{
	t_cmd	*cmds;
	t_cmd	*current;
	int		needs_pipe;

	cmds = NULL;
	current = NULL;
	needs_pipe = command_needs_pipe(tokens);
	return (parse_token_loop(tokens, &cmds, &current, needs_pipe));
}



===== File: ./src/redir/redir_main.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redir_main.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:56:48 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 14:28:02 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "redir.h"

/*
** handle_redirections
** ------------------------------------------------------------
** Iterate over the linked list of redirections attached to a
** command and apply each one.  If any redirection fails the
** function stops processing and returns -1 so the caller can
** handle the error appropriately.  On success it returns 0.
*/
int	handle_redirections(t_cmd *cmd, t_shell *shell)
{
	t_redir	*current;

	if (!cmd || !cmd->redir)
		return (0);
	current = cmd->redir;
	while (current)
	{
		if (redir_apply(current, shell) < 0)
			return (-1);
		current = current->next;
	}
	return (0);
}



===== File: ./src/redir/redir_apply.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redir_apply.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:56:42 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 13:50:20 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "redir.h"

/*
** redir_apply
** ------------------------------------------------------------
** Dispatch function that chooses the correct handler for the
** given redirection node based on its type.  Returns 0 on success
** or -1 if the setup function reports an error or the type is
** unknown.
*/
int	redir_apply(t_redir *redir, t_shell *shell)
{
	if (!redir)
		return (0);
	if (redir->type == TOKEN_REDIR_IN || redir->type == TOKEN_HEREDOC)
		return (setup_redir_input(redir, shell));
	if (redir->type == TOKEN_REDIR_OUT || redir->type == TOKEN_REDIR_APPEND)
		return (setup_redir_output(redir, shell));
	return (-1);
}



===== File: ./src/redir/heredoc.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:56:39 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 13:20:03 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <readline/readline.h>
#include "libft.h"
#include "input.h"
#include "redir.h"

/*
** heredoc
** ------------------------------------------------------------
** Implements the here-document feature.  A pipe is created and
** the user is prompted for input until the delimiter string is
** provided.  The collected lines are written to the pipe and the
** read end of the pipe is returned so it can be used as the
** command's STDIN.  On any error the function returns -1.
*/

int	heredoc(const char *delimiter, t_shell *shell)
{
	int		fd[2];
	char	*line;

	if (pipe(fd) < 0)
		return (-1);
	while (1)
	{
		set_prompt_state(shell, PROMPT_HEREDOC);
		display_prompt(shell);
		line = readline(NULL);
		if (!line || !ft_strncmp(line, delimiter, ft_strlen(delimiter) + 1))
		{
			free(line);
			break ;
		}
		write(fd[1], line, ft_strlen(line));
		write(fd[1], "\n", 1);
		free(line);
	}
	close(fd[1]);
	set_prompt_state(shell, PROMPT_DEFAULT);
	return (fd[0]);
}



===== File: ./src/redir/redir_error.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redir_error.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/06 01:08:50 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/26 23:09:34 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include "redir.h"

int	handle_redir_error(const char *msg)
{
	if (msg)
		perror(msg);
	return (-1);
}



===== File: ./src/redir/redir_output.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redir_output.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/06 15:22:03 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 14:29:12 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include "redir.h"

/*
** open_output_file
** ------------------------------------------------------------
** Opens or creates a file for output redirection.  If `append`
** is non-zero the file is opened in append mode otherwise it is
** truncated.  Returns the new file descriptor or -1 on failure.
*/
int	open_output_file(const char *filename, int append)
{
	int	flags;

	if (!filename)
		return (-1);
	flags = O_WRONLY | O_CREAT;
	if (append)
		flags |= O_APPEND;
	else
		flags |= O_TRUNC;
	return (open(filename, flags, 0644));
}

/*
** setup_redir_output
** ------------------------------------------------------------
** Handles output related redirections ('>' and '>>').  The
** appropriate file is opened and duplicated onto STDOUT.  The
** temporary file descriptor is closed before returning.  Returns
** 0 on success or -1 on failure.
*/
int	setup_redir_output(t_redir *redir, t_shell *shell)
{
	int	fd;
	(void)shell;
	
	if (!redir || !redir->target)
		return (handle_redir_error("redirection"));
	if (redir->type == TOKEN_REDIR_OUT)
		fd = open_output_file(redir->target, 0);
	else if (redir->type == TOKEN_REDIR_APPEND)
		fd = open_output_file(redir->target, 1);
	else
		return (0);
	if (fd < 0)
		return (handle_redir_error(redir->target));
	if (dup2(fd, STDOUT_FILENO) < 0)
	{
		close(fd);
		return (handle_redir_error("dup2"));
	}
	close(fd);
	return (0);
}



===== File: ./src/redir/redir_input.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redir_input.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/06 01:09:31 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 13:48:54 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include "redir.h"

/*
** open_input_file
** ------------------------------------------------------------
** Wrapper around open() for input files.  Returns the file
** descriptor on success or -1 on failure.
*/
int	open_input_file(const char *filename)
{
	if (!filename)
		return (-1);
	return (open(filename, O_RDONLY));
}

/*
** setup_redir_input
** ------------------------------------------------------------
** Handles input related redirections ("<" and heredoc).  It
** obtains the appropriate file descriptor and duplicates it onto
** STDIN.  The original descriptor is closed afterwards.  Returns
** 0 on success or -1 on failure.
*/
int	setup_redir_input(t_redir *redir, t_shell *shell)
{
	int	fd;

	if (!redir || !redir->target)
		return (handle_redir_error("redirection"));
	if (redir->type == TOKEN_REDIR_IN)
		fd = open_input_file(redir->target);
	else if (redir->type == TOKEN_HEREDOC)
		fd = heredoc(redir->target, shell);
	else
		return (0);
	if (fd < 0)
		return (handle_redir_error(redir->target));
	if (dup2(fd, STDIN_FILENO) < 0)
	{
		perror("dup2");
		close(fd);
		return (handle_redir_error("dup2"));
	}
	close(fd);
	return (0);
}



===== File: ./src/builtin/exit.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:52:48 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/26 22:52:03 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtin.h"
#include "libft.h"
#include <stdio.h>

int	count_args(t_cmd *cmd)
{
	int	i;

	i = 0;
	while (cmd->argv && cmd->argv[i])
		i++;
	return (i);
}

int	is_valid_exit_code_arg(const char *arg)
{
	int	i;

	if (!arg)
		return (0);
	i = 0;
	if (arg[i] == '+' || arg[i] == '-')
		i++;
	if (!arg[i])
		return (0);
	while (arg[i])
	{
		if (!ft_isdigit(arg[i]))
			return (0);
		i++;
	}
	return (1);
}

int	builtin_exit(t_cmd *cmd, t_shell *shell)
{
	long	code;

	printf("exit\n");
	if (cmd->argv[1])
	{
		if (!is_valid_exit_code_arg(cmd->argv[1]))
		{
			printf("exit: %s: numeric argument required\n", cmd->argv[1]);
			shell->last_exit_code = 2;
			shell->is_running = 0;
			return (2);
		}
		if (count_args(cmd) > 2)
		{
			printf("exit: too many arguments\n");
			shell->last_exit_code = 1;
			return (1);
		}
		code = ft_atol(cmd->argv[1]);
		shell->last_exit_code = (int)(code & 255);
		shell->is_running = 0;
		return (shell->last_exit_code);
	}
	shell->is_running = 0;
	return (shell->last_exit_code);
}



===== File: ./src/builtin/export.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:52:53 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 16:05:25 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtin.h"
#include "libft.h"
#include <stdio.h>
#include <stdlib.h>

int	validate_export_argument(const char *s)
{
	int	i;

	if (!s || !(ft_isalpha(s[0]) || s[0] == '_'))
		return (0);
	i = 1;
	while (s[i] && s[i] != '=')
	{
		if (!(ft_isalnum(s[i]) || s[i] == '_'))
			return (0);
		i++;
	}
	return (1);
}

int	export_variable(const char *arg, t_shell *shell)
{
	char	*eq;
	char	*key;
	char	*value;
	int		res;

	eq = ft_strchr(arg, '=');
	if (!eq)
		return (set_env_value(&shell->env, arg, ""));
	key = ft_substr(arg, 0, eq - arg);
	value = ft_strdup(eq + 1);
	if (!key || !value)
	{
		free(key);
		free(value);
		return (1);
	}
	res = set_env_value(&shell->env, key, value);
	free(key);
	free(value);
	return (res);
}

int	builtin_export(t_cmd *cmd, t_shell *shell)
{
	int	i;
	int	status;

	if (!cmd->argv[1])
	{
		sort_and_print_env(shell->env);
		return (0);
	}
	status = 0;
	i = 1;
	while (cmd->argv[i])
	{
		if (validate_export_argument(cmd->argv[i]))
		{
			if (export_variable(cmd->argv[i], shell) != 0)
				status = 1;
		}
		else
		{
			printf("export: `%s`: not a valid identifier\n", cmd->argv[i]);
			status = 1;
		}
		i++;
	}
	return (status);
}



===== File: ./src/builtin/env.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:52:47 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 15:52:28 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtin.h"

int	builtin_env(t_cmd *cmd, t_env *env)
{
	(void)cmd;
	print_env_list(env);
	return (0);
}



===== File: ./src/builtin/export_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:52:51 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/26 22:52:15 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtin.h"
#include "libft.h"
#include <stdio.h>
#include <stdlib.h>

static int	env_count(t_env *env)
{
	int	count;

	count = 0;
	while (env)
	{
		count++;
		env = env->next;
	}
	return (count);
}

static void	sort_env_array(t_env **arr, int size)
{
	int		i;
	int		j;
	t_env	*tmp;

	i = 0;
	while (i < size - 1)
	{
		j = i + 1;
		while (j < size)
		{
			if (ft_strncmp(arr[i]->key, arr[j]->key,
					ft_strlen(arr[i]->key) + 1) > 0)
			{
				tmp = arr[i];
				arr[i] = arr[j];
				arr[j] = tmp;
			}
			j++;
		}
		i++;
	}
}

void	sort_and_print_env(t_env *env)
{
	int		size;
	int		i;
	t_env	**arr;

	size = env_count(env);
	arr = malloc(sizeof(t_env *) * size);
	if (!arr)
		return ;
	i = 0;
	while (env)
	{
		arr[i++] = env;
		env = env->next;
	}
	sort_env_array(arr, size);
	i = 0;
	while (i < size)
	{
		if (arr[i]->value && arr[i]->value[0] != '\0')
			printf("declare -x %s=\"%s\"\n", arr[i]->key, arr[i]->value);
		else
			printf("declare -x %s\n", arr[i]->key);
		i++;
	}
	free(arr);
}



===== File: ./src/builtin/dispatcher.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   dispatcher.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:52:41 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 12:25:14 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtin.h"
#include "libft.h"

static int	str_eq(const char *a, const char *b)
{
	return (ft_strncmp(a, b, ft_strlen(a)) == 0
		&& ft_strlen(a) == ft_strlen(b));
}

int	is_builtin(t_cmd *cmd)
{
	if (!cmd || !cmd->argv || !cmd->argv[0])
		return (0);
	if (str_eq(cmd->argv[0], "echo") || str_eq(cmd->argv[0], "cd")
		|| str_eq(cmd->argv[0], "pwd") || str_eq(cmd->argv[0], "env")
		|| str_eq(cmd->argv[0], "export") || str_eq(cmd->argv[0], "unset")
		|| str_eq(cmd->argv[0], "exit"))
		return (1);
	return (0);
}

int	execute_builtin(t_cmd *cmd, t_shell *shell)
{
	if (!cmd || !cmd->argv || !cmd->argv[0])
		return (1);
	if (str_eq(cmd->argv[0], "echo"))
		return (builtin_echo(cmd));
	if (str_eq(cmd->argv[0], "cd"))
		return (builtin_cd(cmd, shell));
	if (str_eq(cmd->argv[0], "pwd"))
		return (builtin_pwd());
	if (str_eq(cmd->argv[0], "env"))
		return (builtin_env(cmd, shell->env));
	if (str_eq(cmd->argv[0], "export"))
		return (builtin_export(cmd, shell));
	if (str_eq(cmd->argv[0], "unset"))
		return (builtin_unset(cmd, shell));
	if (str_eq(cmd->argv[0], "exit"))
		return (builtin_exit(cmd, shell));
	return (1);
}



===== File: ./src/builtin/cd.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd.c                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:52:31 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/26 22:55:59 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtin.h"
#include "libft.h"
#include <unistd.h>
#include <stdio.h>

int	builtin_cd(t_cmd *cmd, t_shell *shell)
{
	char	*target;
	char	*oldpwd;
	char	*cwd;

	target = get_target_path(cmd, shell);
	if (!target)
	{
		printf("cd: HOME not set\n");
		return (1);
	}
	oldpwd = getcwd(NULL, 0);
	if (chdir(target) != 0)
		return (handle_cd_error(oldpwd));
	cwd = getcwd(NULL, 0);
	update_env_dirs(shell, oldpwd, cwd);
	return (0);
}

int	update_pwd(t_shell *shell)
{
	char	*cwd;

	cwd = getcwd(NULL, 0);
	if (!cwd)
		return (1);
	set_env_value(&shell->env, "PWD", cwd);
	free(cwd);
	return (0);
}

int	update_oldpwd(t_shell *shell)
{
	char	*cwd;

	cwd = getcwd(NULL, 0);
	if (!cwd)
		return (1);
	set_env_value(&shell->env, "OLDPWD", cwd);
	free(cwd);
	return (0);
}

int	change_dir(const char *path, t_shell *shell)
{
	char	*oldpwd;

	oldpwd = getcwd(NULL, 0);
	if (chdir(path) != 0)
	{
		perror("cd");
		free(oldpwd);
		return (1);
	}
	if (oldpwd)
	{
		set_env_value(&shell->env, "OLDPWD", oldpwd);
		free(oldpwd);
	}
	update_pwd(shell);
	return (0);
}



===== File: ./src/builtin/pwd.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:00 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/26 22:52:28 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtin.h"
#include <unistd.h>
#include <limits.h>
#include <stdio.h>

int	builtin_pwd(void)
{
	char	cwd[PATH_MAX];

	if (getcwd(cwd, sizeof(cwd)))
	{
		printf("%s\n", cwd);
		return (0);
	}
	perror("pwd");
	return (1);
}



===== File: ./src/builtin/unset.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   unset.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:04 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 16:13:40 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtin.h"

int	builtin_unset(t_cmd *cmd, t_shell *shell)
{
	int	i;

	i = 1;
	while (cmd->argv[i])
	{
		unset_env_value(&shell->env, cmd->argv[i]);
		i++;
	}
	return (0);
}



===== File: ./src/builtin/echo.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:52:44 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 16:19:55 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtin.h"
#include "libft.h"

int	check_echo_flag(char *arg)
{
	int	i;

	if (!arg || arg[0] != '-')
		return (0);
	i = 1;
	if (arg[i] == '\0')
		return (0);
	while (arg[i])
	{
		if (arg[i] != 'n')
			return (0);
		i++;
	}
	return (1);
}

int	builtin_echo(t_cmd *cmd)
{
	int	i;
	int	newline;

	i = 1;
	newline = 1;
	while (cmd->argv[i] && check_echo_flag(cmd->argv[i]))
	{
		newline = 0;
		i++;
	}
	while (cmd->argv[i])
	{
		printf("%s", cmd->argv[i]);
		if (cmd->argv[i + 1])
			printf(" ");
		i++;
	}
	if (newline)
		printf("\n");
	return (0);
}



===== File: ./src/tests/01_pipeline_exec_fork_test.c =====

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <string.h>
#include <errno.h>

#define MAX_CMDS 4

char *test_pipeline[][MAX_CMDS] = {
	{"echo", "hello world", NULL},
	{"ls", "-l", NULL},
	{"grep", ".c", NULL},
	{"wc", "-l", NULL}
};

void fatal(const char *msg)
{
	perror(msg);
	exit(EXIT_FAILURE);
}

void run_test_pipeline(void)
{
	int i = 0;
	int pipes[MAX_CMDS - 1][2];
	pid_t pids[MAX_CMDS];

	while (i < MAX_CMDS - 1)
	{
		if (pipe(pipes[i]) == -1)
			fatal("pipe");
		i++;
	}

	for (i = 0; i < MAX_CMDS; i++)
	{
		pids[i] = fork();
		if (pids[i] < 0)
			fatal("fork");

		if (pids[i] == 0)
		{
			// CHILD PROCESS

			if (i > 0)
			{
				if (dup2(pipes[i - 1][0], STDIN_FILENO) < 0)
					fatal("dup2 stdin");
			}
			if (i < MAX_CMDS - 1)
			{
				if (dup2(pipes[i][1], STDOUT_FILENO) < 0)
					fatal("dup2 stdout");
			}

			// Close all pipe ends in child
			for (int j = 0; j < MAX_CMDS - 1; j++)
			{
				close(pipes[j][0]);
				close(pipes[j][1]);
			}

			execlp(test_pipeline[i][0], test_pipeline[i][0], test_pipeline[i][1], test_pipeline[i][2], NULL);
			fatal("exec");
		}
	}

	// PARENT: Close all pipe ends
	for (i = 0; i < MAX_CMDS - 1; i++)
	{
		close(pipes[i][0]);
		close(pipes[i][1]);
	}

	// Wait all children
	for (i = 0; i < MAX_CMDS; i++)
	{
		int status;
		waitpid(pids[i], &status, 0);
		if (WIFEXITED(status))
			printf("[TEST] Child %d exited with code: %d\n", i, WEXITSTATUS(status));
		else if (WIFSIGNALED(status))
			printf("[TEST] Child %d killed by signal: %d\n", i, WTERMSIG(status));
		else
			printf("[TEST] Unknown termination of child %d\n", i);
	}
}

int main(void)
{
	printf(" [TEST] Running fork + pipeline chain test...\n\n");
	run_test_pipeline();
	printf("\n [TEST COMPLETE] If output makes sense and no leaks => PASS\n");
	return (0);
}


===== File: ./src/main/shell_loop.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   shell_loop.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/26 22:51:11 by procha-r          #+#    #+#             */
/*   Updated: 2025/08/27 14:05:51 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "input.h"
#include "expansion.h"
#include "quotes.h"
#include "signals.h"
#include <readline/readline.h>
#include <readline/history.h>

static void	process_line(char *line, t_shell *shell)
{
	t_token	*tokens;
	t_cmd	*cmds;
	char	*expanded;

	expanded = expand_variables(line, shell->env, shell->last_exit_code);
	free_user_input(line);
	if (!expanded)
		return ;
	if (contains_unclosed_quotes(expanded))
	{
		print_error("Error: unclosed quotes");
		shell->last_exit_code = 2;
		free_user_input(expanded);
		return ;
	}
	tokens = tokenize_input(expanded);
	cmds = parse_tokens_to_cmds(tokens);
	if (cmds)
		execute_pipeline(cmds, shell);
	free_command_list(cmds);
	free_token_list(tokens);
	free_user_input(expanded);
}

int	shell_loop(t_shell *shell)
{
	char	*line;

	init_prompt(shell);
	shell->is_running = 1;
	while (shell->is_running && is_interactive_shell(shell))
	{
		line = read_user_input(shell);
		if (!line)
			break ;
		if (*line)
			add_history(line);
		process_line(line, shell);
		if (g_signal != 0)
		{
			shell->last_exit_code = g_signal;
			g_signal = 0;
		}
		set_last_status(shell, shell->last_exit_code);

	}
	return (0);
}


===== File: ./src/main/main.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/26 20:05:33 by procha-r          #+#    #+#             */
/*   Updated: 2025/08/05 16:54:51 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	main(int argc, char **argv, char **envp)
{
	t_shell	shell;

	(void)argc;
	(void)argv;
	shell.env = init_env_from_environ(envp);
	shell.last_exit_code = 0;
	shell_loop(&shell);
	exit_clean(&shell, 0);
	return (0);
}



===== File: ./src/input/prompt_free.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prompt_free.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/27 14:23:46 by procha-r          #+#    #+#             */
/*   Updated: 2025/08/27 14:24:15 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

void	free_user_input(char *line)
{
	if (line)
		free(line);
}



===== File: ./src/input/readline_config.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   readline_config.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:54:41 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 13:17:12 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <readline/readline.h>
#include "input.h"

void	init_readline(void)
{
	rl_catch_signals = 0;
//	set_prompt_state(PROMPT_DEFAULT);
}



===== File: ./src/input/read_input.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   read_input.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:54:35 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 13:16:44 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <readline/readline.h>
#include <stdlib.h>
#include "input.h"

char	*read_user_input(t_shell *shell)
{
	char	*line;

	set_prompt_state(shell, PROMPT_DEFAULT);
	display_prompt(shell);
	line = readline(NULL);
	if (!line)
	{
		if (is_interactive_shell(shell))
			write(1, "exit\n", 5);
		return (NULL);
	}
	return (line);
}



===== File: ./src/input/prompt_init.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prompt_init.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/27 14:21:36 by procha-r          #+#    #+#             */
/*   Updated: 2025/08/27 14:22:06 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "input.h"
#include <unistd.h>

void	init_prompt(t_shell *shell)
{
	shell->prompt.mode = PROMPT_DEFAULT;
	shell->prompt.last_status = 0;
	shell->prompt.interactive = isatty(STDIN_FILENO);
}



===== File: ./src/input/prompt_state.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prompt_state.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:47:27 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 14:23:58 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "input.h"
#include "libft.h"
#include <unistd.h>

void	display_prompt(t_shell *shell)
{
	if (!shell->prompt.interactive)
		return ;
	if (shell->prompt.mode == PROMPT_HEREDOC)
		write(STDOUT_FILENO, "> ", 2);
	else
	{
		ft_putstr_fd("[", STDOUT_FILENO);
		ft_putnbr_fd(shell->prompt.last_status, STDOUT_FILENO);
		ft_putstr_fd("] minishell$ ", STDOUT_FILENO);
	}
}


===== File: ./src/input/prompt_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prompt_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/27 14:22:40 by procha-r          #+#    #+#             */
/*   Updated: 2025/08/27 14:23:00 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "input.h"

t_prompt_state	get_prompt_state(t_shell *shell)
{
	return (shell->prompt.mode);
}

void	set_prompt_state(t_shell *shell, t_prompt_state state)
{
	shell->prompt.mode = state;
}

void	set_last_status(t_shell *shell, int status)
{
	shell->prompt.last_status = status;
}

int	get_last_status(t_shell *shell)
{
	return (shell->prompt.last_status);
}

int	is_interactive_shell(t_shell *shell)
{
	return (shell->prompt.interactive);
}



===== File: ./src/signals/signal_global.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal_global.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:57:09 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 14:27:05 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "signals.h"
#include "minishell.h"

volatile sig_atomic_t g_signal = 0;

void	set_signal_code(t_shell *shell, int code)
{
	if (shell)
		shell->last_exit_code = code;

}

int	get_signal_code(t_shell *shell)
{
	if (!shell)
		return (1);
	return (shell->last_exit_code);
}



===== File: ./src/signals/signal_init.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal_init.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:57:13 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 14:04:04 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "signals.h"
#include <signal.h>

void    init_signals(void)
{
    disable_echoctl();
    g_signal = 0;
    signal(SIGINT, signal_handler_parent);
    signal(SIGQUIT, signal_handler_parent);
}

void    reset_signals(void)
{
    enable_echoctl();
    signal(SIGINT, signal_handler_child);
    signal(SIGQUIT, signal_handler_child);
}



===== File: ./src/signals/signal_handlers.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal_handlers.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:57:11 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/27 14:04:55 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "signals.h"
#include <signal.h>
#include <readline/readline.h>
#include <unistd.h>

void    signal_handler_parent(int sig)
{
    if (sig == SIGINT)
    {
        g_signal = 130;
        rl_on_new_line();
        rl_replace_line("", 0);
        write(1, "\n", 1);
        rl_redisplay();
    }
    else if (sig == SIGQUIT)
    {
        g_signal = 131;
        rl_on_new_line();
        rl_replace_line("", 0);
        rl_redisplay();
    }
}

void    signal_handler_child(int sig)
{
    if (sig == SIGINT)
    {
        g_signal = 130;
        write(1, "\n", 1);
    }
    else if (sig == SIGQUIT)
    {
        g_signal = 131;
        write(1, "Quit (core dumped)\n", 19);
    }
}



===== File: ./src/signals/signal_echoctl.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal_echoctl.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:57:07 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/06 15:23:11 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "signals.h"
#include <termios.h>
#include <unistd.h>

void	disable_echoctl(void)
{
	struct termios	term;

	if (tcgetattr(STDIN_FILENO, &term) == -1)
		return ;
	term.c_lflag &= ~ECHOCTL;
	tcsetattr(STDIN_FILENO, TCSANOW, &term);
}

void	enable_echoctl(void)
{
	struct termios	term;

	if (tcgetattr(STDIN_FILENO, &term) == -1)
		return ;
	term.c_lflag |= ECHOCTL;
	tcsetattr(STDIN_FILENO, TCSANOW, &term);
}



===== File: ./src/cleanup/exit.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:53:17 by dleite-b          #+#    #+#             */
/*   Updated: 2025/08/05 16:53:18 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cleanup.h"
#include <stdlib.h>
#include <readline/history.h>

void	exit_clean(t_shell *shell, int code)
{
	if (shell)
		free_shell(shell);
	rl_clear_history();
	exit(code);
}



===== File: ./src/cleanup/cleanup.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cleanup.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dleite-b <dleite-b@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/04 15:20:07 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/08/06 13:00:09 by dleite-b         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cleanup.h"
#include <stdlib.h>

void	free_redirections(t_redir *redir)
{
	t_redir	*tmp;

	while (redir)
	{
		tmp = redir->next;
		free(redir->target);
		free(redir);
		redir = tmp;
	}
}

void	free_command(t_cmd *cmd)
{
	if (!cmd)
		return ;
	if (cmd->argv)
		free_split(cmd->argv);
	if (cmd->redir)
		free_redirections(cmd->redir);
	free(cmd);
}

void	free_shell(t_shell *shell)
{
	if (!shell)
		return ;
	if (shell->env)
		free_env_list(shell->env);
}

void	deep_cleanup_on_error(t_shell *shell)
{
	exit_clean(shell, EXIT_FAILURE);
}



