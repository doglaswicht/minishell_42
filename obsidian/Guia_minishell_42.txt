# Guia Completo do Minishell 42

## Visão geral do projeto
- Estrutura de diretórios no padrão 42:
  - include/: cabeçalhos compartilhados (tipos, protótipos, macros).
  - src/: código-fonte organizado por domínio (main, input, tokenizer, parser, expansion, redir, exec, signals, builtins, env, quotes, cleanup, utils, libft).
  - Binário final: ./minishell (linkado com readline).
- Objetivo: replicar o comportamento básico do bash com tratamento de sinais, redirecionamentos, pipes, variáveis de ambiente e builtins obrigatórios.

## Fluxo de execução geral (do ./minishell ao encerramento)
1. Arranque do processo (src/main/main.c)
   - main() zera a estrutura t_shell, inicializa o readline (init_readline), configura sinais (init_signals), carrega o ambiente (init_env_from_environ), define last_exit_code = 0 e entra no laço principal chamando shell_loop().
2. Laço principal (src/main/shell_loop.c)
   - shell_loop() inicializa o prompt, marca is_running = 1 e, enquanto o shell estiver ativo, chama read_user_input().
   - Cada linha lida é encaminhada para process_line() que completa possíveis aspas (read_complete_line), armazena no histórico quando apropriado, expande variáveis (expand_variables), verifica aspas, e por fim passa para validate_and_execute().
3. Leitura da entrada (src/input/read_input.c)
   - read_user_input() decide entre read_interactive() (prompt + readline) ou read_non_interactive_line() (leitura manual por read), tratando interrupções (EINTR) e Ctrl+D.
4. Tokenização (src/tokenizer/)
   - tokenize_input() percorre a string com ajuda de skip_whitespace, handle_word_token e handle_metachar_token, adicionando nós via add_token.
   - Tipos são classificados com token_type e utilitários de metacaracteres.
5. Validação sintática (src/parser/parser_syntax.c)
   - validate_token_syntax() detecta erros de pipe, redirecionamento, tokens proibidos e gera mensagens similares ao bash (minishell: syntax error near unexpected token).
6. Parsing para comandos (src/parser/parser_main.c + utilitários)
   - parse_tokens_to_cmds() converte a lista de tokens em uma lista ligada de t_cmd usando estado interno (handle_pipe_token, create_command_if_needed, process_redirection_node).
   - Funções utilitárias adicionam argumentos (ft_add_arg), redirecionamentos (add_redirection), validam segmentos (count_command_segments, command_needs_pipe).
7. Expansão (src/expansion/)
   - expand_variables() delega para helpers que tratam $, ?, aspas e combinações de strings (loop em expand_loop.c, manipulação de caracteres/dólar, busca em ambiente e status de saída).
8. Preparação do pipeline (src/redir/ e src/exec/)
   - handle_redirections() abre ficheiros (open_input_file, open_output_file), prepara heredoc() e duplica descritores.
   - execute_pipeline() decide entre execução única (execute_single_command) ou pipeline completo (execute_pipeline_commands), abrindo pipes (setup_pipes), criando processos (spawn_child_process), tratando builtins, redireções e restauro de stdio.
9. Execução/builtins (src/builtin/ + src/exec/)
   - No contexto pai: execute_single_command() salva fds, decide se builtin deve ser rodado no pai (handle_builtin_execution), ou chama launch_execve() para binários externos.
   - No filho: child_process_exec() aplica redireções, duplica fds (dup2), resolve path (is_path_absolute_or_relative, is_valid_executable, access), e chama execve.
10. Sincronização e status (src/exec/wait*.c)
    - wait_for_all() aguarda os filhos, traduz status (update_exit_code_from_status), acumula valor em shell->last_exit_code.
11. Limpeza entre ciclos (src/parser/parser_utils.c, src/cleanup/cleanup.c)
    - Liberta tokens, comandos, redirecionamentos e alocações auxiliares.
12. Tratamento de sinais (src/signals/ + src/input/prompt_state.c)
    - Handlers (signal_handler_parent, signal_handler_child) atuam sobre Ctrl+C, Ctrl+\, Ctrl+D alterando g_signal, mensagens e prompt.
13. Encerramento
    - Quando shell->is_running é desativado (builtin exit, EOF, erro grave), shell_loop() termina, exit_clean() liberta todos os recursos e chama exit(code).

## Análise por arquivo (src/)
### Diretório src/main
- main.c: funções main; protótipo int main(int argc, char **argv, char **envp); inicializa shell e chama shell_loop.
- shell_loop.c: funções validate_and_execute, process_line, shell_loop; controlam leitura de linhas, histórico, expansão e atualização de last_exit_code.
- shell_loop_utils.c: reset_line, read_continuation_input, append_extra_input, append_continuation, read_complete_line; mantêm prompt de continuação quando há aspas abertas.

### Diretório src/input
- read_input.c: ensure_capacity, read_stream, read_non_interactive_line, read_interactive, read_user_input; fazem leitura robusta em modo interativo e não interativo.
- readline_config.c: init_readline, configure_readline; configuram a biblioteca readline.
- prompt_init.c: init_prompt; prepara estrutura do prompt.
- prompt_utils.c: build_prompt, format_status; montam string mostrada ao usuário.
- prompt_state.c: set_prompt_state, is_interactive_shell, set_last_status; guardam o estado do prompt e código da última execução.
- prompt_free.c: destroy_prompt; libera buffers.

### Diretório src/tokenizer
- tokenizer.c: skip_whitespace, handle_word_token, handle_metachar_token, tokenize_input; constroem lista de tokens.
- token_utils.c: is_space, is_metachar, add_token, create_token; utilitários para a lista de tokens.
- token_type.c: token_type; classifica tokens para mensagens.
- token_free.c: free_token_list; liberta memória.

### Diretório src/parser
- parser_syntax.c: token_repr, report_syntax_error, check_pipe, check_redirection, validate_token_syntax; valida gramática e gera mensagens estilo bash.
- parser_main.c: handle_pipe_token, create_command_if_needed, process_redirection_node, parse_token_loop, parse_tokens_to_cmds; convertem tokens em comandos encadeados.
- parser_main_utils.c: add_redirection, process_word_token, process_redirection_token; ajudam a montar argv e redirecionamentos.
- parser_split.c: count_command_segments, command_needs_pipe, command_is_empty, is_redirection_token; verificações e contagens para pipelines.
- parser_utils.c: free_command_list, count_argv_len, copy_argv, free_old_argv; gerenciam argv e listas de comandos.
- parser_cmd.c: add_command; adiciona nós na lista de comandos.
- ft_add_arg.c: ft_add_arg; expande vetor argv dinamicamente.

### Diretório src/quotes
- quote_type.c: is_quote, quote_type; identifica aspas simples ou duplas.
- quote_check.c: quotes_balanced, contains_unclosed_quotes, is_quoted_segment; garante alinhamento de aspas.
- quote_strip.c: helpers que removem aspas mantendo o conteúdo literal.

### Diretório src/expansion
- expand_main.c: expand_variables; ponto de entrada das expansões.
- expand_loop.c: funções de varredura que decidem se tratam dólar, juntam literais ou respeitam aspas.
- expand_char_helpers.c: rotinas para montar strings dinamicamente caractere a caractere.
- expand_dollar_helpers.c: extrai nomes de variáveis, trata sequências especiais.
- expand_env.c: get_env_value; busca no ambiente.
- expand_exit.c: converte last status para string.
- expand_utils.c: utilitários gerais de expansão.

### Diretório src/redir
- redir_main.c: handle_redirections; executa pipeline de redirecionamentos para cada comando.
- redir_input.c: open_input_file, setup_redir_input; abre arquivos de entrada.
- redir_output.c: open_output_file, setup_redir_output; cria arquivo de saída ou modo append.
- redir_error.c: handle_redir_error; formata mensagens.
- redir_apply.c: redir_apply; aplica um redirecionamento específico.
- heredoc.c: helpers internos e função heredoc; gera entrada temporária lendo até o delimitador.

### Diretório src/exec
- exec_single.c: restore_stdio, handle_builtin_execution, update_wait_status, execute_single_command; lida com execução única.
- exec_pipeline.c: count_cmds, setup_pipeline_execution, execute_pipeline; organiza pipelines.
- exec_pipeline_helpers.c: setup_fds, execute_single_command_in_pipeline, execute_pipeline_commands; controla iteração sobre comandos em pipelines.
- pipes.c: count_commands, allocate_pipes, setup_pipes, close_all_pipes, free_pipe_fds; gerenciam descritores de pipe.
- exec_fork.c: free_envp, child_process_exec, spawn_child_process, launch_execve; cria processos e chama execve.
- exec_path.c: is_path_absolute_or_relative, is_valid_executable; decide qual binário executar.
- exec_utils.c: handle_exec_error; mensagens para falhas em execve.
- wait.c: wait_for_all; aguarda todos os processos filhos.
- wait_utils.c: update_exit_code_from_status; traduz status do waitpid.

### Diretório src/builtin
- dispatcher.c: str_eq, is_builtin, execute_builtin; detecta e executa builtins.
- echo.c: check_echo_flag, builtin_echo; implementa echo com opção -n.
- cd.c: builtin_cd, update_pwd, update_oldpwd, change_dir; trata mudança de diretório e atualização do ambiente.
- pwd.c: builtin_pwd; imprime diretório atual.
- env.c: builtin_env; lista o ambiente.
- export.c: validate_export_argument, export_variable, builtin_export; insere ou atualiza variáveis.
- export_utils.c: env_count, sort_env_array, sort_and_print_env; ordena saída para export sem argumentos.
- unset.c: builtin_unset; remove variáveis.
- exit.c: report_numeric_error, handle_too_many_args, handle_exit_argument, builtin_exit; controla encerramento do shell.
- exit_utils.c: accumulate_digit, count_args, is_valid_exit_code_arg, parse_exit_value; utilitários do exit.
- echo.c, pwd.c, env.c etc são chamados dentro de execute_builtin, executados no pai quando necessário para manter estado.

### Diretório src/env
- env_init.c: init_env_from_environ; cria lista ligada com o ambiente.
- env_helpers.c: is_valid_env_key, env_key_exists, count_env_nodes, fill_env_array; valida e prepara conversões.
- env_set.c: replace_value (estático), set_env_value; atualiza ambiente.
- env_unset.c: free_env_node (estático), remove_env_node, unset_env_value; remove entradas.
- env_get.c: env_has_key, print_env_list; operações de leitura.
- env_utils.c: add_env_node; insere novas variáveis.
- env_to_str_array.c: converte lista para vetor de strings (usado por execve).
- env_free.c: free_env_list; limpa memória.

### Diretório src/signals
- signal_init.c: init_signals, reset_signals; registra handlers.
- signal_handlers.c: signal_handler_parent, signal_handler_child; respostas específicas a SIGINT/SIGQUIT.
- signal_echoctl.c: disable_echoctl, enable_echoctl; ajustam termios para esconder ^C.
- signal_global.c: set_signal_code, get_signal_code; encapsulam g_signal.

### Diretório src/cleanup
- cleanup.c: free_redirections, free_command, free_shell, deep_cleanup_on_error; rotina de liberação.
- exit.c: exit_clean; encerra shell liberando tudo.

### Diretório src/utils
- error.c: print_error, print_strs; mensagens padrão.
- free_utils.c: free_split; libera arrays.
- malloc_helpers.c: wrappers de alocação defensiva.
- str_utils.c: count_char, split_len, ft_atoi_strict; parse e contagem auxiliar.
- str_join.c: ft_strjoin_free; concatena strings liberando a primeira.
- cd_utils.c: handle_cd_error, update_env_dirs; mensagens e atualização de PWD/OLDPWD.

### Diretório src/libft
- Cada arquivo implementa a função homônima da libft (exemplo: ft_strlen.c possui size_t ft_strlen(const char *s)).
- Agrupamentos principais: caracteres (ft_isalpha etc), strings (ft_strjoin etc), memória (ft_memcpy etc), conversão (ft_atoi, ft_atol, ft_itoa), fd utils (ft_putchar_fd, ft_putstr_fd, ft_putendl_fd, ft_putnbr_fd) e auxiliares adicionais (ft_free_split).

## Guia didático de implementação do zero
1. Libft e utilitários: garanta funções básicas de string/memória e helpers como ft_add_arg, ft_free_split.
2. Estruturas em include/: defina t_shell, t_cmd, t_redir, t_env, enums de token e estados de prompt.
3. Entrada e sinais: configure readline, read_non_interactive_line e handlers via sigaction/tcsetattr.
4. Tokenizer: separe palavras, metacaracteres e aspas; teste com strings simples.
5. Validação sintática: replique mensagens do bash e retorno 258 para erros de sintaxe.
6. Parser: monte lista de comandos com argv, redireções e informação de pipe.
7. Ambiente: carregue variáveis, implemente export/unset/env_to_str_array.
8. Expansão: trate $, 0, aspas simples versus duplas, junção de literais.
9. Redirecionamentos: implemente open/dup2/close, heredoc respeitando Ctrl+C e sem gravar no histórico.
10. Execução: comece com comandos únicos, depois adicione pipelines e sincronização com waitpid.
11. Builtins: execute cd, export, unset, exit no processo pai; echo, pwd, env podem rodar no filho.
12. Cleanup: garanta liberação entre ciclos e ao sair (exit_clean).
13. Polimento final: alinhe mensagens, status, comportamento de sinais e conformidade com a Norm.

## Bibliotecas padrão e chamadas importantes
- readline/readline.h e readline/history.h: readline, add_history, rl_replace_line.
- unistd.h: read, write, access, dup, dup2, pipe, fork, _exit.
- fcntl.h: open com O_CREAT, O_TRUNC, O_APPEND, permissões 0644.
- signal.h: sigaction, sigemptyset, manuseio de SIGINT/SIGQUIT.
- sys/wait.h: waitpid, macros WIFEXITED, WEXITSTATUS, WTERMSIG.
- termios.h: ajustes de echoctl.

## Funções externas essenciais (como usar)
- readline: retorna linha editável; verifique retorno NULL para Ctrl+D.
- rl_replace_line / rl_on_new_line / rl_redisplay: atualizam prompt após sinal.
- access(path, F_OK | X_OK): confirma existência e permissão de execução.
- dup2(oldfd, newfd): redireciona stdin/stdout.
- pipe(fd[2]): cria par de descritores conectados.
- fork(): cria processo filho; sempre trate erros e ramos pai/filho.
- execve(path, argv, envp): carrega binário externo; só retorna em caso de erro.
- waitpid(pid, &status, 0): sincroniza com filhos e obtém status.
- tcsetattr: liga/desliga eco de Ctrl+C/Ctrl+\.

## Exemplos rápidos
- Redirecionar saída: abrir arquivo com open, chamar dup2(fd, STDOUT_FILENO), fechar fd.
- Pipeline simples (ls | wc -l): criar pipe, fork do produtor duplicando fds[1], fork do consumidor usando fds[0], fechar fds no pai e aguardar com waitpid.
- Heredoc: ler linhas até delimitador, gravar em pipe temporário, conectar pipe à entrada do comando.

## Erros comuns e como evitar
- Aspas não fechadas: aguardar continuação com read_complete_line em vez de abortar.
- Tokenizer colando tokens: garantir separação entre palavras e metacaracteres (usar handle_word_token corretamente).
- Mensagens incorretas: replicar formato minishell: comando: mensagem.
- PATH ausente: quando PATH não existe, comandos sem barra devem retornar 127; caminhos absolutos ainda funcionam.
- Sinais: no prompt, Ctrl+C limpa linha e mostra prompt novo; Ctrl+\ deve ser ignorado no prompt; durante execução deve repassar sinais a filhos.
- Builtins no contexto errado: cd, export, unset, exit precisam rodar no pai.
- Heredoc somando ao histórico: utilize readline sem add_history durante o loop.
- Vazamento de descritores: sempre fechar fds de pipe em todos os processos após duplicar.

## Dicas de teste
1. Testes unitários por módulo (tokenizer, parser, redireções, expansion).
2. Scripts automatizados redirecionando comandos via echo "cmd" | ./minishell.
3. Bater saída com /bin/bash para conferir stdout, stderr e status.
4. Valgrind ou sanitizers (quando possível) para capturar vazamentos.
5. Stress com loops, pipelines longos, variáveis enormes, combinação de aspas.

## Boas práticas finais
- Libere memória a cada iteração (free_token_list, free_command_list, free_shell).
- Centralize logs de erro e códigos de retorno.
- Utilize g_signal para comunicar sinais entre handlers e laço principal.
- Garanta aderência à Norm: funções curtas, sem variáveis globais desnecessárias, sem ternários proibidos.
- Envolva malloc/calloc em helpers que abortam ou reportam erros de forma consistente.

---
Este guia resume o fluxo completo, o papel de cada arquivo e orienta a implementação passo a passo seguindo o padrão da 42.

## Quadro de protótipos (arquivos principais)
### src/main
- main.c
  - int main(int argc, char **argv, char **envp)
- shell_loop.c
  - static void validate_and_execute(char *expanded, t_shell *shell)
  - static void process_line(char *line, t_shell *shell)
  - int shell_loop(t_shell *shell)
- shell_loop_utils.c
  - static void reset_line(char **line, t_shell *shell, int code)
  - static int read_continuation_input(char **extra, t_shell *shell)
  - static int append_extra_input(char **line, char *extra, t_shell *shell)
  - static int append_continuation(char **line, t_shell *shell)
  - char *read_complete_line(char *line, t_shell *shell)

### src/input
- read_input.c
  - static char *ensure_capacity(char *line, size_t *cap, size_t current_len, size_t extra)
  - static int read_stream(char **line, size_t *len, size_t *cap)
  - static char *read_non_interactive_line(void)
  - static char *read_interactive(t_shell *shell)
  - char *read_user_input(t_shell *shell)
- readline_config.c
  - void init_readline(void)
  - void configure_readline(void)
- prompt_init.c
  - void init_prompt(t_shell *shell)
- prompt_utils.c
  - char *build_prompt(t_shell *shell)
  - char *format_status(int status)
- prompt_state.c
  - void set_prompt_state(t_shell *shell, t_prompt_state state)
  - int is_interactive_shell(t_shell *shell)
  - void set_last_status(t_shell *shell, int status)
- prompt_free.c
  - void destroy_prompt(t_shell *shell)

### src/tokenizer
- tokenizer.c
  - static void skip_whitespace(const char *line, int *i)
  - static void handle_word_token(const char *line, int *i, t_token **head)
  - static void handle_metachar_token(const char *line, int *i, t_token **head)
  - t_token *tokenize_input(const char *line)
- token_utils.c
  - int is_space(char c)
  - int is_metachar(char c)
  - void add_token(t_token **list, t_token *new)
  - t_token *create_token(t_token_type type, const char *value)
- token_type.c
  - int token_type(const char *str)
- token_free.c
  - void free_token_list(t_token *head)

### src/parser
- parser_syntax.c
  - static const char *token_repr(t_token *token)
  - static void report_syntax_error(t_shell *shell, t_token *token)
  - static int check_pipe(t_token *token, t_token *prev, t_shell *shell)
  - static int check_redirection(t_token *token, t_shell *shell)
  - int validate_token_syntax(t_token *tokens, t_shell *shell)
- parser_main.c
  - static void handle_pipe_token(t_cmd ***current, int state[3])
  - static int create_command_if_needed(t_token *token, t_cmd ***current, t_cmd **cmds, int state[3])
  - static int process_redirection_node(t_cmd *current, t_token **tokens, t_cmd **cmds)
  - static t_cmd *parse_token_loop(t_token *tokens, t_cmd **cmds, t_cmd **current, int state[3])
  - t_cmd *parse_tokens_to_cmds(t_token *tokens)
- parser_main_utils.c
  - void add_redirection(t_redir **list, t_redir *new_redir)
  - int process_word_token(t_cmd *current, t_token *token)
  - int process_redirection_token(t_cmd *current, t_token **tokens)
- parser_split.c
  - int count_command_segments(t_token *tokens)
  - int command_needs_pipe(t_token *tokens)
  - int command_is_empty(t_cmd *cmd)
  - int is_redirection_token(t_token *token)
- parser_utils.c
  - void free_command_list(t_cmd *cmds)
  - size_t count_argv_len(char **argv)
  - void copy_argv(char **new_argv, char **argv)
  - void free_old_argv(char **argv)
- parser_cmd.c
  - void add_command(t_cmd **cmds, t_cmd *new_cmd)
- ft_add_arg.c
  - void ft_add_arg(char ***argv, const char *value)

### src/quotes
- quote_type.c
  - int is_quote(char c)
  - int quote_type(char c)
- quote_check.c
  - int quotes_balanced(const char *line)
  - int contains_unclosed_quotes(const char *s)
  - int is_quoted_segment(const char *s, int index)
- quote_strip.c
  - Funções estáticas que removem aspas preservando o texto (consultar arquivo para detalhes específicos).

### src/expansion
- expand_main.c
  - char *expand_variables(const char *input, t_env *env, int last_status)
- expand_loop.c
  - Funções estáticas que percorrem caracteres e direcionam para tratadores de dólar ou literais.
- expand_char_helpers.c
  - Helpers estáticos para juntar segmentos de string (ex.: append_char, join_segment)
- expand_dollar_helpers.c
  - Helpers estáticos para extrair nomes de variáveis, testar limites e montar substituições
- expand_env.c
  - char *get_env_value(const char *key, t_env *env)
- expand_exit.c
  - char *expand_exit_status(int status)
- expand_utils.c
  - Funções auxiliares para resetar buffers e validar caracteres

### src/redir
- redir_main.c
  - int handle_redirections(t_cmd *cmd, t_shell *shell)
- redir_input.c
  - int open_input_file(const char *filename)
  - int setup_redir_input(t_redir *redir, t_shell *shell)
- redir_output.c
  - int open_output_file(const char *filename, int append)
  - int setup_redir_output(t_redir *redir, t_shell *shell)
- redir_error.c
  - int handle_redir_error(const char *msg)
- redir_apply.c
  - int redir_apply(t_redir *redir, t_shell *shell)
- heredoc.c
  - static int process_heredoc_input(int fd, char *line, const char *delimiter, int *aborted)
  - static int finalise_heredoc(int fd, t_shell *shell, int aborted)
  - int heredoc(const char *delimiter, t_shell *shell)

### src/exec
- exec_single.c
  - static void restore_stdio(int saved[2])
  - static int handle_builtin_execution(t_cmd *cmd, t_shell *shell)
  - static void update_wait_status(int status, t_shell *shell)
  - int execute_single_command(t_cmd *cmd, t_shell *shell)
- exec_pipeline.c
  - static int count_cmds(t_cmd *cmds)
  - static int setup_pipeline_execution(t_cmd *cmds, t_shell *shell)
  - int execute_pipeline(t_cmd *cmds, t_shell *shell)
- exec_pipeline_helpers.c
  - void setup_fds(int fds[2], int index, t_shell *shell)
  - int execute_single_command_in_pipeline(t_cmd *cmd, t_shell *shell, int fds[2], int is_last)
  - int execute_pipeline_commands(t_cmd *cmds, t_shell *shell)
- pipes.c
  - static int count_commands(t_cmd *cmds)
  - static int allocate_pipes(int ***pipes, int count)
  - int setup_pipes(t_cmd *cmds, int ***pipes)
  - void close_all_pipes(int **pipes, int count)
  - void free_pipe_fds(int **pipes, int count)
- exec_fork.c
  - static void free_envp(char **envp)
  - void child_process_exec(t_cmd *cmd, t_shell *shell, int is_last)
  - int spawn_child_process(t_cmd *cmd, t_shell *shell, int *fds, int is_last)
  - int launch_execve(t_cmd *cmd, t_shell *shell)
- exec_path.c
  - int is_path_absolute_or_relative(const char *cmd)
  - int is_valid_executable(const char *path)
- exec_utils.c
  - void handle_exec_error(const char *msg)
- wait.c
  - int wait_for_all(t_cmd *cmds, t_shell *shell)
- wait_utils.c
  - int update_exit_code_from_status(int status)

### src/builtin
- dispatcher.c
  - static int str_eq(const char *a, const char *b)
  - int is_builtin(t_cmd *cmd)
  - int execute_builtin(t_cmd *cmd, t_shell *shell)
- echo.c
  - int check_echo_flag(char *arg)
  - int builtin_echo(t_cmd *cmd)
- cd.c
  - int builtin_cd(t_cmd *cmd, t_shell *shell)
  - int update_pwd(t_shell *shell)
  - int update_oldpwd(t_shell *shell)
  - int change_dir(const char *path, t_shell *shell)
- pwd.c
  - int builtin_pwd(void)
- env.c
  - int builtin_env(t_cmd *cmd, t_env *env)
- export.c
  - int validate_export_argument(const char *s)
  - int export_variable(const char *arg, t_shell *shell)
  - int builtin_export(t_cmd *cmd, t_shell *shell)
- export_utils.c
  - static int env_count(t_env *env)
  - static void sort_env_array(t_env **arr, int size)
  - void sort_and_print_env(t_env *env)
- unset.c
  - int builtin_unset(t_cmd *cmd, t_shell *shell)
- exit.c
  - static int report_numeric_error(const char *arg, t_shell *shell)
  - static int handle_too_many_args(t_shell *shell)
  - static int handle_exit_argument(t_cmd *cmd, t_shell *shell, int argc)
  - int builtin_exit(t_cmd *cmd, t_shell *shell)
- exit_utils.c
  - static int accumulate_digit(unsigned long long *uvalue, char c, int sign)
  - int count_args(t_cmd *cmd)
  - int is_valid_exit_code_arg(const char *arg)
  - int parse_exit_value(const char *arg, long long *value)

### src/env
- env_init.c
  - t_env *init_env_from_environ(char **envp)
- env_helpers.c
  - int is_valid_env_key(const char *key)
  - int env_key_exists(t_env *env, const char *key)
  - size_t count_env_nodes(t_env *env)
  - int fill_env_array(char **arr, t_env *env)
- env_set.c
  - static int replace_value(t_env *node, const char *value)
  - int set_env_value(t_env **env, const char *key, const char *value)
- env_unset.c
  - static void free_env_node(t_env *node)
  - static int remove_env_node(t_env **env, t_env *cur, t_env *prev)
  - int unset_env_value(t_env **env, const char *key)
- env_get.c
  - int env_has_key(t_env *env, const char *key)
  - void print_env_list(t_env *env)
- env_utils.c
  - void add_env_node(char *key, char *value, t_env **env_list)
- env_to_str_array.c
  - char **env_to_str_array(t_env *env)
- env_free.c
  - void free_env_list(t_env *env)

### src/signals
- signal_init.c
  - void init_signals(void)
  - void reset_signals(void)
- signal_handlers.c
  - void signal_handler_parent(int sig)
  - void signal_handler_child(int sig)
- signal_echoctl.c
  - void disable_echoctl(void)
  - void enable_echoctl(void)
- signal_global.c
  - void set_signal_code(t_shell *shell, int code)
  - int get_signal_code(t_shell *shell)

### src/cleanup
- cleanup.c
  - void free_redirections(t_redir *redir)
  - void free_command(t_cmd *cmd)
  - void free_shell(t_shell *shell)
  - void deep_cleanup_on_error(t_shell *shell)
- exit.c
  - void exit_clean(t_shell *shell, int code)

### src/utils
- error.c
  - void print_error(const char *msg)
  - void print_strs(char **arr)
- free_utils.c
  - void free_split(char **arr)
- malloc_helpers.c
  - Funções de alocação defensiva (ex.: void *malloc_or_exit(size_t size))
- str_utils.c
  - int count_char(const char *str, char c)
  - int split_len(char **arr)
  - int ft_atoi_strict(const char *str, int *out)
- str_join.c
  - char *ft_strjoin_free(char *s1, char *s2)
- cd_utils.c
  - int handle_cd_error(char *oldpwd)
  - void update_env_dirs(t_shell *shell, char *oldpwd, char *cwd)

### src/libft
- Cada arquivo expõe a função tradicional da libft, por exemplo:
  - ft_strlen.c: size_t ft_strlen(const char *s)
  - ft_strdup.c: char *ft_strdup(const char *s)
  - ft_strjoin.c: char *ft_strjoin(const char *s1, const char *s2)
  - ft_memcpy.c: void *ft_memcpy(void *dst, const void *src, size_t n)
  - ft_atoi.c: int ft_atoi(const char *str)
  - ft_atol.c: long ft_atol(const char *str)
  - ft_split.c: char **ft_split(const char *s, char c)
  - ft_putchar_fd.c: void ft_putchar_fd(char c, int fd)
  - ft_putstr_fd.c: void ft_putstr_fd(const char *s, int fd)
  - ft_putendl_fd.c: void ft_putendl_fd(const char *s, int fd)
  - ft_putnbr_fd.c: void ft_putnbr_fd(int n, int fd)
  - ft_free_split.c: void ft_free_split(char **arr)
- Consulte libft.h para a lista completa; todas seguem a convenção 42.
